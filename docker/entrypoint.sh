#!/bin/sh
set -eu

node -v >/dev/null

mkdir -p /data

APP_ENV_FILE="${APP_ENV_FILE:-/app/.env}"
SECRETS_FILE="${MCP_NEXUS_SECRETS_FILE:-/data/mcp-nexus.secrets.env}"
ADMIN_TOKEN_FILE="${MCP_NEXUS_ADMIN_TOKEN_FILE:-/data/mcp-nexus.admin-token}"

# Load a mounted env file (useful for `docker run -v $PWD/.env:/app/.env ...`).
# NOTE: Parse as data (KEY=VALUE) rather than `source` to avoid executing shell code.
load_env_file() {
  file="$1"
  if [ ! -f "$file" ]; then
    return 0
  fi

  echo "Loading environment from $file"

  while IFS= read -r line || [ -n "$line" ]; do
    line="$(printf '%s' "$line" | tr -d '\r')"
    case "$line" in
      ''|\#*) continue ;;
    esac

    case "$line" in
      export\ *) line="${line#export }" ;;
    esac

    case "$line" in
      *=*) : ;;
      *) continue ;;
    esac

    key="${line%%=*}"
    val="${line#*=}"

    # Only accept safe variable names.
    case "$key" in
      [A-Za-z_]*)
        case "$key" in
          *[!A-Za-z0-9_]*)
            continue ;;
        esac
        ;;
      *)
        continue ;;
    esac

    # If already set, keep the existing value (docker -e / compose env should win).
    eval "cur=\${$key-}"
    if [ -n "$cur" ]; then
      continue
    fi

    # Strip optional surrounding quotes.
    case "$val" in
      \"*\") val="${val#\"}"; val="${val%\"}" ;;
      \'*\') val="${val#\'}"; val="${val%\'}" ;;
    esac

    export "$key=$val"
  done < "$file"
}

load_env_file "$APP_ENV_FILE"

# Container-friendly defaults (only applied when missing/empty)
: "${HOST:=0.0.0.0}"
: "${PORT:=8787}"
: "${DATABASE_URL:=file:/data/tavily_bridge.db}"
export HOST PORT DATABASE_URL

PERSISTED_KEY=""
PERSISTED_ADMIN=""
if [ -f "$SECRETS_FILE" ]; then
  while IFS= read -r line || [ -n "$line" ]; do
    line="$(printf '%s' "$line" | tr -d '\r')"
    case "$line" in
      ''|\#*) continue ;;
    esac
    key="${line%%=*}"
    val="${line#*=}"
    case "$key" in
      KEY_ENCRYPTION_SECRET) PERSISTED_KEY="$val" ;;
      ADMIN_API_TOKEN) PERSISTED_ADMIN="$val" ;;
    esac
  done < "$SECRETS_FILE"
fi

# If secrets were previously generated, reuse them (only when missing/empty)
if [ -z "${KEY_ENCRYPTION_SECRET:-}" ] && [ -n "$PERSISTED_KEY" ]; then
  export KEY_ENCRYPTION_SECRET="$PERSISTED_KEY"
fi

if [ -z "${ADMIN_API_TOKEN:-}" ] && [ -n "$PERSISTED_ADMIN" ]; then
  export ADMIN_API_TOKEN="$PERSISTED_ADMIN"
fi

GENERATED_KEY=0
GENERATED_ADMIN=0

if [ -z "${KEY_ENCRYPTION_SECRET:-}" ]; then
  KEY_ENCRYPTION_SECRET="$(node -e "console.log(require('crypto').randomBytes(32).toString('base64'))")"
  export KEY_ENCRYPTION_SECRET
  GENERATED_KEY=1
fi

if [ -z "${ADMIN_API_TOKEN:-}" ]; then
  ADMIN_API_TOKEN="$(node -e "console.log(require('crypto').randomBytes(32).toString('hex'))")"
  export ADMIN_API_TOKEN
  GENERATED_ADMIN=1
fi

# Persist newly generated secrets in the /data volume so restarts remain stable.
if [ "$GENERATED_KEY" -eq 1 ] || [ "$GENERATED_ADMIN" -eq 1 ]; then
  (
    umask 077
    tmp="$(mktemp "${SECRETS_FILE}.tmp.XXXXXX")"
    {
      echo "# Auto-generated by mcp-nexus container startup"
      if [ "$GENERATED_KEY" -eq 1 ]; then
        echo "KEY_ENCRYPTION_SECRET=$KEY_ENCRYPTION_SECRET"
      elif [ -n "$PERSISTED_KEY" ]; then
        echo "KEY_ENCRYPTION_SECRET=$PERSISTED_KEY"
      fi
      if [ "$GENERATED_ADMIN" -eq 1 ]; then
        echo "ADMIN_API_TOKEN=$ADMIN_API_TOKEN"
      elif [ -n "$PERSISTED_ADMIN" ]; then
        echo "ADMIN_API_TOKEN=$PERSISTED_ADMIN"
      fi
    } > "$tmp"
    mv "$tmp" "$SECRETS_FILE"
  )
  echo "Persisted generated secrets to $SECRETS_FILE"
fi

if [ "$GENERATED_ADMIN" -eq 1 ]; then
  (
    umask 077
    if [ -L "$ADMIN_TOKEN_FILE" ]; then
      echo "Refusing to write admin token to symlink: $ADMIN_TOKEN_FILE" >&2
      exit 1
    fi
    printf '%s\n' "$ADMIN_API_TOKEN" > "$ADMIN_TOKEN_FILE"
    chmod 600 "$ADMIN_TOKEN_FILE"
  )

  if [ "${PRINT_BOOTSTRAP_SECRETS:-}" = "true" ] || [ "${PRINT_BOOTSTRAP_SECRETS:-}" = "1" ]; then
    echo ""
    echo "=============================="
    echo "Generated ADMIN_API_TOKEN:"
    echo "  $ADMIN_API_TOKEN"
    echo "Use it to sign in at: /admin"
    echo "=============================="
    echo ""
  else
    echo "Generated ADMIN_API_TOKEN saved to $ADMIN_TOKEN_FILE (mode 600)."
    echo "To retrieve:"
    echo "  docker exec <container> sh -lc 'cat $ADMIN_TOKEN_FILE'"
    echo "To print at startup, set PRINT_BOOTSTRAP_SECRETS=true"
  fi
fi

# Fail fast with a helpful error if the encryption key is invalid.
node - <<'NODE'
const raw = (process.env.KEY_ENCRYPTION_SECRET ?? '').trim();
if (!raw) {
  console.error('KEY_ENCRYPTION_SECRET is required.');
  process.exit(1);
}
const isHex = /^[0-9a-fA-F]{64}$/.test(raw);
const key = Buffer.from(raw, isHex ? 'hex' : 'base64');
if (key.length !== 32) {
  console.error(`KEY_ENCRYPTION_SECRET must decode to 32 bytes (got ${key.length}).`);
  process.exit(1);
}
NODE

npx --no-install prisma migrate deploy --schema packages/db/prisma/schema.prisma

exec node packages/bridge-server/dist/index.js
